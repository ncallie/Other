import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Program {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int countTest = Integer.parseInt(reader.readLine());
        for (int t = 0; t < countTest; t++) {

            String[] strY_X = reader.readLine().split(" ");
            boolean isShift = false;

            int y = Integer.parseInt(strY_X[0]);
            int x = Integer.parseInt(strY_X[1]);
            char [][] map = new char[y][x];
            for (int i = 0; i < y; ++i) {
                map[i] = reader.readLine().replace('.', '~').toCharArray();
            }

            for (int i = 0; i < y; ++i) { //скидываем кубики вниз
                for(int j = 0; j < x; ++j) {
                    if (i + 1 < y) {
                        if (map[i][j] == '*' && map[i + 1][j] == '~') {
                            map[i + 1][j] = '*';
                            map[i][j] = '~';
                            i = 0;
                            isShift = true;}
                    }
                }
                if (isShift) {
                    i = -1;
                    isShift = false;
                }
            }

            for (int i = 0; i < y; ++i) { //чистим воду слева
                for(int j = 0; j < x; ++j) {
                    if (map[i][0] == '~') {
                        map[i][0] = '.';
                    }
                    if (j - 1 >= 0) {
                        if (map[i][j] == '~' && map[i][j - 1] == '.') {
                            map[i][j] = '.';
                            map[i][j - 1] = '~';
                            j = -1;
                            continue;
                        }
                    }
                }
            }
            for (int i = 0; i < y; ++i) { //чистим воду справа
                for(int j = x - 1; j >= 0; --j) {
                    if (map[i][x - 1] == '~') {
                        map[i][x - 1] = '.';
                    }
                    if (j + 1 < x) {
                        if (map[i][j] == '~' && (map[i][j + 1] == '.')) {
                            map[i][j] = '.';
                            map[i][j + 1] = '~';
                            j = x;
                            continue;
                        }
                    }
                }
            }
            for (char [] line : map) {
                System.out.println(line);
            }
            System.out.println();
        }
    }
}

// F. Двумерная игра (25 баллов)
// ограничение по времени на тест6 секунд
// ограничение по памяти на тест256 мегабайт
// вводстандартный ввод
// выводстандартный вывод
// Вы разрабатываете двумерную игру. Поле представляет собой прямоугольник 𝑛×𝑚 (𝑛 строк по 𝑚 клеток в каждой).

// Каждая клетка поля либо пустая, либо содержит каменный блок 1×1. Когда начинается игра все блоки падают максимально вниз. Картинка ниже иллюстрирует этот процесс.

// Пример поля 5×10: слева изображено исходное поле, справа  — после падения всех блоков вниз.
// После этого поле затапливает вода, которая под действием силы тяжести стремится покинуть поле. Считайте, что слева и справа от поля находится пустота, а поле расположено на поверхности (то есть нижняя граница поля не пропускает воду). В результате такого потопа на поле могут остаться юниты воды. Вода может оставаться на поле, если она оказывается огорожена блоками (следуйте здравому смыслу и рисунку ниже, чтобы понять правила того, как вода остается на поле).

// Справа изображено состояние поля после потопа.
// Напишите программу, которая по начальному состоянию поля вернёт его состояние после потопа.

// Входные данные
// В первой строке записано целое число 𝑡 (1≤𝑡≤104) — количество наборов входных данных в тесте.

// Далее следуют описания наборов.

// Первая строка описания содержит два целых числа 𝑛, 𝑚 (1≤𝑛≤104, 1≤𝑚≤106) — размеры поля. Гарантируется, что суммарное количество клеток поля не превосходит 106 (то есть 𝑛⋅𝑚≤106).

// Далее следуют 𝑛 строк по 𝑚 символов в каждой — начальное состояние поля. Каждая строка содержит только символы '.' (пустая клетка поля) и '*' (каменный блок).

// Гарантируется, что сумма количеств клеток по всем наборам входных данных в тесте не превосходит 106.

// Выходные данные
// Для каждого набора входных данных выведите финальное состояние поля. Юнит воды надо обозначать символом '~' (тильда, ascii-код 126).

// После каждого поля выводите перевод строки.

